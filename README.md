# Android Weather Assessment: A Developer’s Growth Journey

### Overview

When I first joined DVT three years ago, I completed a Weather Assessment that challenged me to build a feature-rich Android application. Reflecting on that project today, I believe I demonstrated strong skills in writing clean, maintainable code, following best practices such as Dependency Injection, MVVM, and Room for persistence.

## Previous assessment link
You can view the original project/assessment which I developed here https://github.com/lbnkosi/dvtweatherapp-android.

As I redo this assessment now, my focus has evolved. Rather than creating another feature-packed app, I set new goals to showcase my growth as a developer. My intent is to highlight how I’ve matured over the years, not only in coding but in understanding the full Software Development Lifecycle (SDL) and its value to businesses, developers, and stakeholders.

## Previous Assessment (Frame of Reference)

In my initial assessment, I placed a strong emphasis on:

1. Writing Clean, Over-Engineered Code: I aimed to showcase my ability to build applications that follow best practices in terms of structure, clarity, and maintainability.
   
2. Adhering to Clean Architecture: I implemented a layered architecture that provided separation of concerns and flexibility for future updates.
   
3. MVVM Pattern: Ensured a clear separation of the UI logic from business logic, allowing for easy testing and modularization.
   
4. Feature-Rich Application: The project included multiple features such as Weather data, Street View integration, Maps, and a Portfolio section. I even created a SpringBoot API to back the app, aiming to demonstrate my backend and frontend integration skills.

This project was a reflection of my technical abilities at the time, showing that I could handle complex architectures and a wide range of features.

## Current Assessment: Shifting Focus

For this iteration, I decided to take a different approach. My goal was to move away from over-engineering and instead focus on aspects that provide real-world value across the app development lifecycle. Specifically, I’ve centered my work around the following key objectives:

1. ### Unit Testing and TDD (Test-Driven Development):

	•	This time, I adopted a TDD approach, emphasizing the importance of testing in the development process. By writing tests before the actual implementation, I aimed to ensure robust, bug-free code.
	•	With maximum code coverage as a goal, I concentrated on making the codebase more reliable, giving future developers confidence in making changes.

2. ### Reducing Boilerplate Code and Complexity

	•	Instead of adding layers of abstraction and complexity, I focused on simplifying the codebase wherever possible. This approach reduces overhead for future development and maintenance, leading to more efficient workflows.
	•	The goal was to cut down on unnecessary code and optimize for clarity and maintainability.

3. ### Using Jetpack Compose

	•	I embraced Jetpack Compose for building the UI, recognizing it as the future of Android development. Compose simplifies UI development by making it more declarative, reducing the need for complex view hierarchies.
	•	This also allowed me to showcase my adaptability to modern Android development tools and techniques.

4. ### End-to-End SDL Understanding

	•	Throughout this project, I took a holistic approach to development, focusing not only on code but also on the Android app lifecycle, performance optimization, and delivering value to stakeholders.
	•	I aimed to demonstrate my ability to balance developer needs with business goals, ensuring that the project aligns with broader organizational objectives.

## Conclusion

While the previous assessment reflected my technical proficiency and ability to handle complex codebases, this project showcases my growth as a developer who now prioritizes simplicity, efficiency, and collaboration. By focusing on areas such as TDD, code coverage, and modern Android development practices like Jetpack Compose, I believe this project offers real value not just to developers but also to the business as a whole.

## What I've done
- [x] Clean Arch, MVVM, Solid 
- [x] Jetpack Compose
- [x] Unit Tests & TDD (Not 100% coverage, not enough time)
- [x] Simplified code
- [x] Used OpenWeatherMap to show weather as well as daily forecast. Added caching as well
- [x] Added ability to search for a place, show it on Google maps and save it locally

## Languages, libraries and tools used

* Kotlin
* Jetpack Compose
* Android Support Libraries
* Jetpack Libraries
* Retrofit
* Room
* Hilt (Depedency injection)
* Dagger (Depedency injection)
* Stetho
* Google Play Services
* Stream Support
* Gson
* Various Unit Test Libraries
* And More

## Requirements

* OpenWeatherMap Api Key
* Google Maps Api Key
* Android Device - minSdkVersion 29
* Android Studio

## Additional Comments
Due to time constraints, I wasn’t able to fully showcase the current project as I had originally envisioned. However, I’ve attached a link to another Android project that I developed, which demonstrates a wider range of skills and technologies. This project includes a custom API built using Spring, MongoDB, and AWS. It also integrates GitHub Actions and Secrets, along with AppCenter, to implement a CI/CD pipeline that automates APK deployment.

Portfolio Android App: https://github.com/lbnkosi/PortfolioAndroidApp

Portfolio Spring Boot API: https://github.com/lbnkosi/PortfolioRestApi-Springboot
